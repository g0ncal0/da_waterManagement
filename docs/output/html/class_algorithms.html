<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WaterManagement: Algorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WaterManagement
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Project DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="class_algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aca5f88ed74f04f85be9d4e0ff3b36fc9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#aca5f88ed74f04f85be9d4e0ff3b36fc9">calculateWaterInCities</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:aca5f88ed74f04f85be9d4e0ff3b36fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0752472d06829fa16eb15b1593de6a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a5b0752472d06829fa16eb15b1593de6a">BFSEdmondsKarp</a> (<a class="el" href="class_graph.html">Graph</a> *g, std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; q)</td></tr>
<tr class="separator:a5b0752472d06829fa16eb15b1593de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ad3955ec9ff8d7a3009b0946bdbe4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a000ad3955ec9ff8d7a3009b0946bdbe4">simpleEdmondsKarp</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:a000ad3955ec9ff8d7a3009b0946bdbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94d05c54eaf4a5f82ce7ca8455a0e3b"><td class="memItemLeft" align="right" valign="top"><a id="ad94d05c54eaf4a5f82ce7ca8455a0e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>simpleEdmondsKarpThatDoesntDeleteSourceAndSink</b> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:ad94d05c54eaf4a5f82ce7ca8455a0e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98155c0db9ec071e43871a79b16da827"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="class_city.html">City</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a98155c0db9ec071e43871a79b16da827">CitiesWithNotEnoughWater</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:a98155c0db9ec071e43871a79b16da827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0b71b919f8851e5626728df593f075"><td class="memItemLeft" align="right" valign="top"><a id="a4d0b71b919f8851e5626728df593f075"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ChooseBalanceTheLoad</b> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:a4d0b71b919f8851e5626728df593f075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d052c6f352a6bd571a369d44e65365"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a73d052c6f352a6bd571a369d44e65365">BalanceTheLoad</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:a73d052c6f352a6bd571a369d44e65365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4222431dc75943848e127bee23d7a8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#adf4222431dc75943848e127bee23d7a8">auxBFSBalanceTheLoad</a> (<a class="el" href="class_graph.html">Graph</a> *g, std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; q, const std::string &amp;source, const std::string &amp;sink, int &amp;maxFlow)</td></tr>
<tr class="separator:adf4222431dc75943848e127bee23d7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bd6e86693010f8e50d41909bac76be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a22bd6e86693010f8e50d41909bac76be">BalanceTheLoad2</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="separator:a22bd6e86693010f8e50d41909bac76be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6644c2b4134abac2d83df6a43dbb57"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a4a6644c2b4134abac2d83df6a43dbb57">findPathToReservoir</a> (<a class="el" href="class_graph.html">Graph</a> *g, <a class="el" href="class_vertex.html">Vertex</a> *origin, std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;path)</td></tr>
<tr class="separator:a4a6644c2b4134abac2d83df6a43dbb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd942408e417520e2c4ee10699352a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a17dd942408e417520e2c4ee10699352a">findAugmentationPathToReservoir</a> (<a class="el" href="class_graph.html">Graph</a> *g, <a class="el" href="class_vertex.html">Vertex</a> *origin, std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;path)</td></tr>
<tr class="separator:a17dd942408e417520e2c4ee10699352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa3df8fe52f5e6ee143de1f5ba5d8d0"><td class="memItemLeft" align="right" valign="top"><a id="a1fa3df8fe52f5e6ee143de1f5ba5d8d0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>shutDownReservoir</b> (<a class="el" href="class_graph.html">Graph</a> *graph)</td></tr>
<tr class="separator:a1fa3df8fe52f5e6ee143de1f5ba5d8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56700d43c26584bb718c059e664451b7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a56700d43c26584bb718c059e664451b7">CanShutDownReservoir</a> (<a class="el" href="class_graph.html">Graph</a> *graph, const std::string &amp;reservoirCode)</td></tr>
<tr class="memdesc:a56700d43c26584bb718c059e664451b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the change in water reaching the cities when a reservoir is removed. It is not optimized, as it will run the Edmonds-Karp algorithm from the beginning. <br  />
Output: If no errors occur, nothing will be printed <br  />
Complexity: O(V * E^2)  <a href="class_algorithms.html#a56700d43c26584bb718c059e664451b7">More...</a><br /></td></tr>
<tr class="separator:a56700d43c26584bb718c059e664451b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432fab0eedd6fb75c90715922758c6c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#ac432fab0eedd6fb75c90715922758c6c">CanShutDownReservoirOptimized</a> (<a class="el" href="class_graph.html">Graph</a> *graph, const std::string &amp;reservoirCode)</td></tr>
<tr class="memdesc:ac432fab0eedd6fb75c90715922758c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the change in water reaching the cities when a reservoir is removed. It is optimized, so that the Edmonds-Karp does not need to be run in its entirety. However, the standard incoming flows of cities must already be set at the beginning of the algorithm. It is assumed that the super-source and super-sink exist in the graph. Due to this precondition, the wrapper function void shutDownReservoir(Graph* graph) was created. <br  />
Output: If no errors occur, nothing will be printed <br  />
Complexity: In the worst case, it could be the same as running the Edmonds-Karp algorithm from zero (O(V * E^2)), but, in a lot of cases, a solution can be reached with a small number of iterations.  <a href="class_algorithms.html#ac432fab0eedd6fb75c90715922758c6c">More...</a><br /></td></tr>
<tr class="separator:ac432fab0eedd6fb75c90715922758c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3588b95447b0b9c80a63725a07941a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#aae3588b95447b0b9c80a63725a07941a">deletePumpingStation</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="memdesc:aae3588b95447b0b9c80a63725a07941a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the change in water reaching the cities when a pumping station is removed. Output: Cities that have lost water are printed, alongside the amount of water in cubic meters per second Complexity: O(V * E^2), because, even though it runs the optimized algorithm, it still calls the Edmonds-Karp algorithm before, to obtain the "default" flows arriving at the cities.  <a href="class_algorithms.html#aae3588b95447b0b9c80a63725a07941a">More...</a><br /></td></tr>
<tr class="separator:aae3588b95447b0b9c80a63725a07941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4181aa6ddc11f5c97b2ebfe90106dc0"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#ab4181aa6ddc11f5c97b2ebfe90106dc0">CanDeletePumpingStationOptimized</a> (<a class="el" href="class_graph.html">Graph</a> *graph, const std::string &amp;stationCode)</td></tr>
<tr class="memdesc:ab4181aa6ddc11f5c97b2ebfe90106dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the change in water reaching the cities when a pumping station is removed. It is optimized, so that the Edmonds-Karp does not need to be run in its entirety. However, the standard incoming flows of cities must already be set at the beginning of the algorithm. It is assumed that the super-source and super-sink exist in the graph. Due to this precondition, the wrapper function void shutDownReservoir(Graph* graph) was created. <br  />
Output: If successful, nothing is printed Complexity: In the worst case, it could be the same as running the Edmonds-Karp algorithm from zero (O(V * E^2)), but, in a lot of cases, a solution can be reached with a small number of iterations.  <a href="class_algorithms.html#ab4181aa6ddc11f5c97b2ebfe90106dc0">More...</a><br /></td></tr>
<tr class="separator:ab4181aa6ddc11f5c97b2ebfe90106dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8521fdfc592e6e5a5f5c79963222d2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a8d8521fdfc592e6e5a5f5c79963222d2">CanDeletePumpingStationFrom0</a> (<a class="el" href="class_graph.html">Graph</a> *graph, const std::string &amp;stationCode)</td></tr>
<tr class="memdesc:a8d8521fdfc592e6e5a5f5c79963222d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the change in water reaching the cities when a pumping station is removed. It runs the Edmonds-Karp algorithm from the beginning. Output: If successful, nothing is printed Complexity: O(V * E^2)  <a href="class_algorithms.html#a8d8521fdfc592e6e5a5f5c79963222d2">More...</a><br /></td></tr>
<tr class="separator:a8d8521fdfc592e6e5a5f5c79963222d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d77a6702888a6614ca8c2c22198ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a989d77a6702888a6614ca8c2c22198ef">criticalPipelines</a> (<a class="el" href="class_graph.html">Graph</a> *graph)</td></tr>
<tr class="separator:a989d77a6702888a6614ca8c2c22198ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0f3304ee97676dd3ac12f83733bd0c"><td class="memItemLeft" align="right" valign="top"><a id="a7f0f3304ee97676dd3ac12f83733bd0c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>PipelineDeletionImpact</b> (<a class="el" href="class_graph.html">Graph</a> *graph)</td></tr>
<tr class="separator:a7f0f3304ee97676dd3ac12f83733bd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a54920fc67976dc38d4dced9bf451d1d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a54920fc67976dc38d4dced9bf451d1d2">RemoveSourceAndSink</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="memdesc:a54920fc67976dc38d4dced9bf451d1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function removes the super-source and super-sink vertices. <br  />
 Output: Nothing is printed Complexity: O(V)  <a href="class_algorithms.html#a54920fc67976dc38d4dced9bf451d1d2">More...</a><br /></td></tr>
<tr class="separator:a54920fc67976dc38d4dced9bf451d1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae048440f38249aa91fe90889b6ded8b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#ae048440f38249aa91fe90889b6ded8b6">AddSourceAndSink</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="memdesc:ae048440f38249aa91fe90889b6ded8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function adds the super-source and super-sink vertices, calculating an appropriate flow for their edges from the one already present in the graph. <br  />
 Output: Nothing is printed Complexity: O(V) (could be made O(1) by removing the error checking)  <a href="class_algorithms.html#ae048440f38249aa91fe90889b6ded8b6">More...</a><br /></td></tr>
<tr class="separator:ae048440f38249aa91fe90889b6ded8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b4b3375b3295fdf4323c856583258"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#afb2b4b3375b3295fdf4323c856583258">SetFlowToZero</a> (<a class="el" href="class_graph.html">Graph</a> *graph)</td></tr>
<tr class="memdesc:afb2b4b3375b3295fdf4323c856583258"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function resets all flow in the graph. <br  />
 Output: Nothing is printed Complexity: O(V + E)  <a href="class_algorithms.html#afb2b4b3375b3295fdf4323c856583258">More...</a><br /></td></tr>
<tr class="separator:afb2b4b3375b3295fdf4323c856583258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5dd768fdd723278bb4cf4bc565da6d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#ade5dd768fdd723278bb4cf4bc565da6d">EdmondsKarpThatIgnoresVertex</a> (<a class="el" href="class_graph.html">Graph</a> *graph, <a class="el" href="class_vertex.html">Vertex</a> *vertx)</td></tr>
<tr class="memdesc:ade5dd768fdd723278bb4cf4bc565da6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper runs a slightly altered Edmonds-Karp algorithm that ignores a vertex. The graph isn't initialized or altered in any way in the beginning, so that the function can be run "in the middle" of bigger algorithms. It assumes that the super-source and super-sink exist in the graph. <br  />
 Output: Nothing is printed Complexity: O(V * E^2)  <a href="class_algorithms.html#ade5dd768fdd723278bb4cf4bc565da6d">More...</a><br /></td></tr>
<tr class="separator:ade5dd768fdd723278bb4cf4bc565da6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae048440f38249aa91fe90889b6ded8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae048440f38249aa91fe90889b6ded8b6">&#9670;&nbsp;</a></span>AddSourceAndSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::AddSourceAndSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function adds the super-source and super-sink vertices, calculating an appropriate flow for their edges from the one already present in the graph. <br  />
 Output: Nothing is printed Complexity: O(V) (could be made O(1) by removing the error checking) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to add the vertices to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf4222431dc75943848e127bee23d7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4222431dc75943848e127bee23d7a8">&#9670;&nbsp;</a></span>auxBFSBalanceTheLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Algorithms::auxBFSBalanceTheLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A BFS that tries to find an augmentation path between source and sink. O(V + E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
    <tr><td class="paramname">q</td><td>the queue that contains the pointer to the source in the beginning </td></tr>
    <tr><td class="paramname">source</td><td>the code of source </td></tr>
    <tr><td class="paramname">sink</td><td>the code of sink </td></tr>
    <tr><td class="paramname">maxFlow</td><td>of the augmentation path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could find an augmentation path </dd></dl>

</div>
</div>
<a id="a73d052c6f352a6bd571a369d44e65365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d052c6f352a6bd571a369d44e65365">&#9670;&nbsp;</a></span>BalanceTheLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::BalanceTheLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>BalanceTheLoad with the logic of redirecting excess water to another augmentation path. O((V + E)²) -&gt; O((V+E) * (V + E)) -&gt; for each vertex for each incoming edge does a few (mostly between 0-2) BFS searches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22bd6e86693010f8e50d41909bac76be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bd6e86693010f8e50d41909bac76be">&#9670;&nbsp;</a></span>BalanceTheLoad2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::BalanceTheLoad2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>BalanceTheLoad with the logic of taking excess water and trying to put that water in another augmentation path. O((V + E)³ * E) -&gt; O((V + E) * (V + E) * E * (V + E)) -&gt; for each vertex for each incoming edge does one BFS search, then for each incoming edge of that vertex does a few (mostly between 0-2) BFS searches. This complexity is only in the very worst case; the real complexity is much lower because even the first BFS won't run in a large part of vertexes, the majority of the BFS are not complete, and the factor E is just the incoming edges of that vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0752472d06829fa16eb15b1593de6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0752472d06829fa16eb15b1593de6a">&#9670;&nbsp;</a></span>BFSEdmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Algorithms::BFSEdmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A BFS search to find an augmentation path in g. O (V + E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
    <tr><td class="paramname">q</td><td>the queue that contains the pointers to the reservoirs in the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could find an augmentation path </dd></dl>

</div>
</div>
<a id="aca5f88ed74f04f85be9d4e0ff3b36fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5f88ed74f04f85be9d4e0ff3b36fc9">&#9670;&nbsp;</a></span>calculateWaterInCities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::calculateWaterInCities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A simple algorithm to calculate the water that enters every city O(n). Changes the totalwaterin var in the cities. O(N) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d8521fdfc592e6e5a5f5c79963222d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8521fdfc592e6e5a5f5c79963222d2">&#9670;&nbsp;</a></span>CanDeletePumpingStationFrom0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt; Algorithms::CanDeletePumpingStationFrom0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>stationCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the change in water reaching the cities when a pumping station is removed. It runs the Edmonds-Karp algorithm from the beginning. Output: If successful, nothing is printed Complexity: O(V * E^2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to run this operation. </td></tr>
    <tr><td class="paramname">stationCode</td><td>The pumping station to remove from the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4181aa6ddc11f5c97b2ebfe90106dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4181aa6ddc11f5c97b2ebfe90106dc0">&#9670;&nbsp;</a></span>CanDeletePumpingStationOptimized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt; Algorithms::CanDeletePumpingStationOptimized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>stationCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the change in water reaching the cities when a pumping station is removed. It is optimized, so that the Edmonds-Karp does not need to be run in its entirety. However, the standard incoming flows of cities must already be set at the beginning of the algorithm. It is assumed that the super-source and super-sink exist in the graph. Due to this precondition, the wrapper function void shutDownReservoir(Graph* graph) was created. <br  />
Output: If successful, nothing is printed Complexity: In the worst case, it could be the same as running the Edmonds-Karp algorithm from zero (O(V * E^2)), but, in a lot of cases, a solution can be reached with a small number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to run this operation. </td></tr>
    <tr><td class="paramname">stationCode</td><td>The pumping station to remove from the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56700d43c26584bb718c059e664451b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56700d43c26584bb718c059e664451b7">&#9670;&nbsp;</a></span>CanShutDownReservoir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt; Algorithms::CanShutDownReservoir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reservoirCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the change in water reaching the cities when a reservoir is removed. It is not optimized, as it will run the Edmonds-Karp algorithm from the beginning. <br  />
Output: If no errors occur, nothing will be printed <br  />
Complexity: O(V * E^2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to run this operation </td></tr>
    <tr><td class="paramname">reservoirCode</td><td>The reservoir which we are attempting to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac432fab0eedd6fb75c90715922758c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432fab0eedd6fb75c90715922758c6c">&#9670;&nbsp;</a></span>CanShutDownReservoirOptimized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_city_water_loss.html">CityWaterLoss</a> &gt; Algorithms::CanShutDownReservoirOptimized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reservoirCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the change in water reaching the cities when a reservoir is removed. It is optimized, so that the Edmonds-Karp does not need to be run in its entirety. However, the standard incoming flows of cities must already be set at the beginning of the algorithm. It is assumed that the super-source and super-sink exist in the graph. Due to this precondition, the wrapper function void shutDownReservoir(Graph* graph) was created. <br  />
Output: If no errors occur, nothing will be printed <br  />
Complexity: In the worst case, it could be the same as running the Edmonds-Karp algorithm from zero (O(V * E^2)), but, in a lot of cases, a solution can be reached with a small number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to run this operation </td></tr>
    <tr><td class="paramname">reservoirCode</td><td>The reservoir which we are attempting to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98155c0db9ec071e43871a79b16da827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98155c0db9ec071e43871a79b16da827">&#9670;&nbsp;</a></span>CitiesWithNotEnoughWater()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_city.html">City</a> * &gt; Algorithms::CitiesWithNotEnoughWater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverses all cities, checking if amount of water reached is enough. O(n), where n is the number of vertixes of graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of cities that do not have enough water </dd></dl>

</div>
</div>
<a id="a989d77a6702888a6614ca8c2c22198ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989d77a6702888a6614ca8c2c22198ef">&#9670;&nbsp;</a></span>criticalPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::criticalPipelines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check critical pipelines by city. Uses a recursive algorithm that finds pipes that are likely to be critical. O(V * (V + E)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae3588b95447b0b9c80a63725a07941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3588b95447b0b9c80a63725a07941a">&#9670;&nbsp;</a></span>deletePumpingStation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::deletePumpingStation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the change in water reaching the cities when a pumping station is removed. Output: Cities that have lost water are printed, alongside the amount of water in cubic meters per second Complexity: O(V * E^2), because, even though it runs the optimized algorithm, it still calls the Edmonds-Karp algorithm before, to obtain the "default" flows arriving at the cities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to run this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5dd768fdd723278bb4cf4bc565da6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5dd768fdd723278bb4cf4bc565da6d">&#9670;&nbsp;</a></span>EdmondsKarpThatIgnoresVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::EdmondsKarpThatIgnoresVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper runs a slightly altered Edmonds-Karp algorithm that ignores a vertex. The graph isn't initialized or altered in any way in the beginning, so that the function can be run "in the middle" of bigger algorithms. It assumes that the super-source and super-sink exist in the graph. <br  />
 Output: Nothing is printed Complexity: O(V * E^2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to run the algorithm on </td></tr>
    <tr><td class="paramname">vertx</td><td>The vertex to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17dd942408e417520e2c4ee10699352a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd942408e417520e2c4ee10699352a">&#9670;&nbsp;</a></span>findAugmentationPathToReservoir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Algorithms::findAugmentationPathToReservoir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to find an augmentation path with a few space between origin and one reservoir with a BFS. O(V + E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
    <tr><td class="paramname">origin</td><td>the code of origin </td></tr>
    <tr><td class="paramname">path</td><td>a vector where we save the path between origin and a reservoir </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could find a path </dd></dl>

</div>
</div>
<a id="a4a6644c2b4134abac2d83df6a43dbb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6644c2b4134abac2d83df6a43dbb57">&#9670;&nbsp;</a></span>findPathToReservoir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Algorithms::findPathToReservoir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to find a path with a few flow between origin and one reservoir with a BFS. O(V + E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
    <tr><td class="paramname">origin</td><td>the code of origin </td></tr>
    <tr><td class="paramname">path</td><td>a vector where we save the path between origin and a reservoir </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could find a path </dd></dl>

</div>
</div>
<a id="a54920fc67976dc38d4dced9bf451d1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54920fc67976dc38d4dced9bf451d1d2">&#9670;&nbsp;</a></span>RemoveSourceAndSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::RemoveSourceAndSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function removes the super-source and super-sink vertices. <br  />
 Output: Nothing is printed Complexity: O(V) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to remove the vertices from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2b4b3375b3295fdf4323c856583258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2b4b3375b3295fdf4323c856583258">&#9670;&nbsp;</a></span>SetFlowToZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::SetFlowToZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function resets all flow in the graph. <br  />
 Output: Nothing is printed Complexity: O(V + E) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to reset the flow in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000ad3955ec9ff8d7a3009b0946bdbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ad3955ec9ff8d7a3009b0946bdbe4">&#9670;&nbsp;</a></span>simpleEdmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::simpleEdmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple Edmonds-Karp using BFS. O(V E²) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/goncalo/Desktop/DA/watermanagement/Algorithms/<a class="el" href="_algorithms_8h_source.html">Algorithms.h</a></li>
<li>/home/goncalo/Desktop/DA/watermanagement/Algorithms/Algorithms.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
